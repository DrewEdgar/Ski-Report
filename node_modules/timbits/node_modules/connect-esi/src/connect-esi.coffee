http = require 'http'
url = require 'url'
querystring = require 'querystring'
out = (require 'styout').instance 'connect-esi'

out.verbosity = out.WARN_VERBOSITY

exports.setupESI = (options) ->
	options = if options? then options else { 'esi': 'true' } # set default options if none given

	# client request can process esi
	req_is_esi_capable = (headers) ->
		return (String(headers['surrogate-capability']).indexOf('ESI/1.0') != -1) || (String(headers['surrogate-capabilities']).indexOf('ESI/1.0') != -1) || (String(headers['accept-esi']) != 'undefined')

	# response is type text
	res_is_text = (content_type) ->
		return /text|xml|octet-stream/i.test(content_type)

	# return response content type
	res_content_type = (headers) ->
		return if headers? and headers['content-type']? then headers['content-type'] else 'text/plain'

	return (req, res, next) ->
		endCalled = false
		endWait = false

		if options['esi'] == 'auto'
			handleESI = !req_is_esi_capable(req.headers) # check if request is esi compatible
		else if options['esi'] == 'false'
			handleESI = false
		else
			handleESI = true
		handleESI = if /esi=false/.test(req.url) then false else handleESI # url override of esi

		if handleESI # esi handling enabled, modify res.write and res.end
			# res.write filter/hook
			write = res.write  # store the original function
			res.write = (chunk, encoding) -> # wrap write to hook into the exit path through the layers
				res.write = write # put the original back
				content_type = res_content_type(res._headers)
				if res_is_text(content_type) # response is type text
					out.debug "res.write | req.url: " + req.url
					endWait = true
					if typeof(chunk) == 'string'
						strchunk = chunk
					else # convert chunk to string if necessary
						strchunk = chunk.toString(if encoding? then encoding else 'utf8')
					esiProcessor = new exports.processESI strchunk, (esiFound, newchunk) ->
						out.debug "processESI callback | req.url: " + req.url
						endWait = false
						if esiFound # esi was found and replaced
							res.setHeader 'content-type', content_type
							res.removeHeader 'content-length' # will recalculate header length when removed
						res.write (if esiFound then newchunk else chunk), encoding
						if endCalled
							res.end()
					esiProcessor.request = req.headers
					esiProcessor.request.url = url.parse('http://' + req.headers['host'] + req.url, true)
					esiProcessor.execute()
				else
					res.write chunk, encoding # call the original
					if endCalled
						res.end()

			# res.end filter/hook
			end = res.end
			res.end = (data, encoding) ->
				endCalled = true
				out.debug "res.end | data: " + data? + " | wait: " + endWait + " | req.url: " + req.url
				if data?
					res.write data, encoding
				else if endWait == false # if not waiting (for async)
					res.end = end
					res.end()

		next() # pass through to the next layer

exports.processESI = (data, callback) ->
	@data = data
	@callback = callback
	@request = {'url': url.parse('http://localhost:5678')} # set default host
	@esi_tags = []
	@processed = false

	@execute = ->
		out.info "Searching for ESIs..."
		@esi_tags = @searchESI @data
		out.info "Found " + @esi_tags.length + " ESIs"
		if (@esi_tags.length != 0) # there are ESIs to process
			for esi_tag in @esi_tags
				out.info "Fetch ESI: " + esi_tag
				@fetchESI esi_tag, (src, status, body) =>
					if status >= 400
						body = '' # remove error messages from body if http status is 4xx or 5xx
						out.warn "ESI: " + src + " returned status " + status
					else
						out.debug "ESI: " + src + " returned status " + status
					out.info "ESI tag subsitution: " + src
					remaining = @subESI src, body
					out.info remaining + " remaining ESIs"
					if remaining == 0 and @processed is false # no remaining ESIs to process, callback
						@processed = true # flag to prevent callback from ever being called twice
						@callback true, @data
		else
			@callback false, @data # send back original

	@searchESI = (data) ->
		re = new RegExp('<esi[^>]* src=("[^>"]+"|\'[^>\']+\')[^>]*>(</esi[^>]*>)?', 'gi')
		esi_tags = data.match(re)
		for k of esi_tags
			re = new RegExp(' src=("(.*?)"|\'(.*?)\')')
			match = esi_tags[k].match(re)
			esi_tags[k] = match[2] ? match[3] # quotes surrounding src: 2 - double, 3 - single
			processed_esi_tag = @processESIvars esi_tags[k]
			if esi_tags[k] isnt processed_esi_tag # esi tag contained esi variables, replace esi in body with processed one
				@subESI esi_tags[k], "<esi:include src='#{processed_esi_tag}' />"
				esi_tags[k] = processed_esi_tag
		removeDuplicates = (arr) ->
			narr = []
			obj = {}
			for k,v in arr
				obj[arr[v]] = 0
			for i of obj
				narr.push i
			return narr
		esi_tags = removeDuplicates esi_tags ? []
		return esi_tags

	@fetchESI = (src, callback) ->
		uri = url.parse(src)
		options =
			host: uri.hostname ? @request.url.hostname
			port: uri.port ? (if uri.protocol? then 80 else @request.url.port)
			path: (uri.pathname ? '/') + (uri.search ? '') + (uri.hash ? '')
		http.get(options, (res) ->
			body = ''
			res.on 'data', (chunk) =>
				body += chunk.toString()
			res.on 'end', =>
				callback src, res.statusCode, body
		).on 'error', (e) ->
			callback src, 500, e.message

	@subESI = (src, body) ->
		re = new RegExp('<esi[^>]* src=("' + RegExp.escape(src) + '"|\'' + RegExp.escape(src) + '\')[^>]*>(</esi[^>]*>)?', 'gi')
		@data = @data.replace(re, body.replace(/\$/g,'$$$')) # if story contains $ escape it
		idx = @esi_tags.indexOf(src)
		@esi_tags.splice idx, 1  unless idx is -1
		return @esi_tags.length # number of ESIs remaining

	@processESIvars = (data) ->
		re = new RegExp('\\$\\([^\\)]+\\)', 'gi')
		esi_vars = data.match(re)
		for i of esi_vars
			re = new RegExp('\\(([^{\\|\\)]*)({([^}]*)})?(\\|([^\\|{)]*))?\\)', 'i')
			esi_var = esi_vars[i].match(re)
			esi_var_result = @lookupESIvar(esi_var[1], esi_var[3])
			if !esi_var_result and esi_var[5]? # set default if exists
				esi_var_result = esi_var[5]
			data = data.replace(esi_vars[i], esi_var_result)
		data

	@lookupESIvar = (esi_var, options) ->
		result = ''
		switch esi_var.toUpperCase()
			when 'HTTP_ACCEPT_LANGUAGE'
				result = @request['accept-language']
			when 'HTTP_COOKIE'
				result = ''
				if options?
					re = new RegExp('(^| )' + options + '=([^;]*)', 'i')
					cookie = @request['cookie'] ? ''
					matches = cookie.match(re)
					if matches?
						result = matches[2]
			when 'HTTP_HEADER'
				result = @request[options]
			when 'HTTP_HOST'
				result = @request['host']
			when 'HTTP_REFERER'
				result = @request['referer']
			when 'HTTP_USER_AGENT'
				result = @request['user-agent']
			when 'QUERY_STRING'
				if options?
					result = @request.url.query[options]
				else
					result = querystring.stringify @request.url.query
		result ?= ''
		return encodeURIComponent(result)

	RegExp.escape = (text) ->
	  text.replace /[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"

	return