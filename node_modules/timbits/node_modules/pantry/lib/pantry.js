// Generated by CoffeeScript 1.3.1
(function() {
  var EventEmitter, Log, MemoryStorage, config, inProgress, log, querystring, request, url, xml2js;

  url = require('url');

  querystring = require('querystring');

  request = require('request');

  xml2js = require('xml2js');

  EventEmitter = require('events').EventEmitter;

  MemoryStorage = require('./pantry-memory');

  Log = require('coloured-log');

  config = {
    shelfLife: 60,
    maxLife: 300,
    caseSensitive: true,
    verbosity: 'ERROR',
    xmlOptions: {}
  };

  log = new Log(config.verbosity);

  inProgress = {};

  this.storage = null;

  this.backup = new MemoryStorage(config);

  this.configure = function(options) {
    var k, v;
    for (k in options) {
      v = options[k];
      config[k] = v;
    }
    log = new Log(config.verbosity);
    return config;
  };

  this.fetch = function(options, callback) {
    var k, v,
      _this = this;
    if (typeof options === 'string') {
      options = {
        uri: options
      };
    }
    for (k in config) {
      v = config[k];
      if (options[k] == null) {
        options[k] = v;
      }
    }
    if ((options.method != null) && options.method !== 'GET') {
      options.maxLife = 0;
    }
    if (options.key == null) {
      options.key = this.generateKey(options);
    }
    return this.fromCache(options.key, function(error, resource) {
      var stock, _base;
      if (resource == null) {
        resource = {};
      }
      resource.options = options;
      if (!_this.hasSpoiled(resource)) {
        log.info("using cached data: " + resource.options.key);
        callback(null, resource.results);
        callback = null;
      }
      if (_this.hasExpired(resource)) {
        stock = inProgress[options.key];
        if (stock != null) {
          log.info("waiting for new data: " + resource.options.key);
          if (callback) {
            return stock.once('done', callback);
          }
        } else {
          log.info("requesting new data: " + resource.options.key);
          stock = new EventEmitter();
          inProgress[options.key] = stock;
          stock.resource = resource;
          if (callback) {
            stock.once('done', callback);
          }
          if ((_base = resource.options).headers == null) {
            _base.headers = {};
          }
          if (resource.etag != null) {
            resource.options.headers['if-none-match'] = resource.etag;
          }
          if (resource.lastModified != null) {
            resource.options.headers['if-modified-since'] = resource.lastModified;
          }
          try {
            return request(options, function(error, response, body) {
              var contentType, parser, start;
              if (error != null) {
                return _this.done(error, stock);
              } else {
                switch (response.statusCode) {
                  case 304:
                    log.info("cached data still good: " + resource.options.key);
                    return _this.done(null, stock);
                  case 200:
                    log.info("new data available: " + options.key);
                    contentType = response.headers["content-type"];
                    if (response.headers['etag'] != null) {
                      resource.etag = response.headers['etag'];
                    }
                    if (response.headers['last-modified'] != null) {
                      resource.lastModified = response.headers['last-modified'];
                    }
                    if (options.parser === 'xml' || contentType.search(/[\/\+]xml/) > 0) {
                      start = body.indexOf('<');
                      if (start) {
                        body = body.slice(start, body.length);
                      }
                      parser = new xml2js.Parser(options.xmlOptions);
                      parser.on('end', function(results) {
                        resource.results = results;
                        return _this.done(null, stock);
                      });
                      return parser.parseString(body);
                    } else if (typeof body === 'string') {
                      try {
                        resource.results = JSON.parse(body);
                        return _this.done(null, stock);
                      } catch (err) {
                        return _this.done(err, stock);
                      }
                    } else {
                      resource.results = body;
                      return _this.done(null, stock);
                    }
                    break;
                  default:
                    return _this.done("Invalid Response Code (" + response.statusCode + ")", stock);
                }
              }
            });
          } catch (err) {
            return _this.done(err, stock);
          }
        }
      }
    });
  };

  this.fromCache = function(key, callback) {
    var _this = this;
    if (this.storage == null) {
      this.storage = this.backup;
    }
    return this.storage.get(key, function(error, resource) {
      if (!(error != null)) {
        return callback(error, resource);
      } else {
        log.error("Problems with primary storage " + key);
        return _this.backup.get(key, function(error, resource) {
          return callback(error, resource);
        });
      }
    });
  };

  this.done = function(err, stock) {
    var resource,
      _this = this;
    delete inProgress[stock.resource.options.key];
    if (err != null) {
      log.error("" + err);
      return stock.emit('done', err);
    } else {
      resource = stock.resource;
      resource.lastPurchased = new Date();
      if (resource.firstPurchased == null) {
        resource.firstPurchased = resource.lastPurchased;
      }
      resource.bestBefore = new Date(resource.lastPurchased);
      resource.bestBefore.setSeconds(resource.bestBefore.getSeconds() + resource.options.shelfLife);
      resource.spoilsOn = new Date(resource.lastPurchased);
      resource.spoilsOn.setSeconds(resource.spoilsOn.getSeconds() + resource.options.maxLife);
      if (resource.options.maxLife === 0) {
        return stock.emit('done', error, resource.results);
      } else {
        stock.emit('done', null, resource.results);
        return this.storage.put(resource, function(error) {
          if (error != null) {
            log.error("Could not cache resource " + resource.options.key + ": " + error);
            return _this.backup.put(resource);
          }
        });
      }
    }
  };

  this.generateKey = function(options) {
    var k, keys, query, uri, _i, _len;
    uri = url.parse(options.uri, true);
    keys = [];
    for (k in uri.query) {
      keys.push(k);
    }
    keys.sort();
    query = {};
    for (_i = 0, _len = keys.length; _i < _len; _i++) {
      k = keys[_i];
      if (uri.query.hasOwnProperty(k)) {
        query[options.caseSensitive ? k : k.toLowerCase()] = uri.query[k];
      }
    }
    uri.search = querystring.stringify(query);
    if (!options.caseSensitive) {
      uri.pathname = uri.pathname.toLowerCase();
    }
    return url.format(uri);
  };

  this.hasSpoiled = function(resource) {
    return !(resource.results != null) || (new Date()) > resource.spoilsOn;
  };

  this.hasExpired = function(resource) {
    return this.hasSpoiled(resource) || (new Date()) > resource.bestBefore;
  };

}).call(this);
